(* ported version of Minos to work with the ARM backend of the Fox Compiler Suite *)
MODULE Modules;

(*@
	001 2007-03-20 fn: New version based on old Modules Module, adapted to new compiler
*)

IMPORT SYSTEM, Kernel, Platform, OFS, Strings, Tools, Heaps, Log;
	
	CONST
		OK*= 0; NOTFOUND* = 1; NOTARM* = 2;  WRONGKEY*=3; NOMEMORY* = 4;

		MaxImports = 32;
TYPE Name = ARRAY 32 OF CHAR;

	Command* = POINTER TO CommandDesc;
	CommandDesc = RECORD
		next*: Command;
		offset: LONGINT;
		name*: Name
	END;
	
	EntryTable = POINTER TO EntryTableDesc;
	EntryTableDesc = RECORD
		entry: ARRAY 256 OF LONGINT
	END;

	Module* = POINTER TO ModuleDesc;
	ModuleDesc = RECORD 
		next*: Module;
		key-: LONGINT;				(* Unique key of Module *)
		dbase, pbase*: LONGINT;		(* dbase : Base address of Module Variables, pbase: Base address of code *)
		size*, refcnt*: LONGINT;		(* size: code size in bytes, rofcnt: reference counter *)
		command*: Command;		(* First command *)
		entrytable: EntryTable;		(* Array containing the offset rel to pbase for each exported function *)
		name*: Name				(* Name of module *)
	END;

	(*! STUDENT:
		Although a part of the information necessary for unloading a module is already weaved-in in ModuleDesc above,
		we need a bit more information.
		But: The static linker relies on the fact that a module has the form of the record above. Therefore we cannot add further
		fields in the ModuleDesc. Trick: use extension of a module. (This will also help to distinguish modules linked into the kernel from
		those that are dynamically loaded. I suggest the following extension:
	*)


	DynamicModule* = POINTER TO DynamicModuleDesc;
	DynamicModuleDesc = RECORD(ModuleDesc)
		imports: ARRAY MaxImports OF Module		(* The list of all modules that this module imports *)
	END;

VAR root*: Module;
	res: LONGINT; errstring*: ARRAY 32 OF CHAR;

PROCEDURE GetRes*(VAR err: ARRAY OF CHAR): LONGINT;
BEGIN
	Strings.Copy(errstring, err);
	RETURN res
END GetRes;

PROCEDURE JoinExtension (CONST name, extension: ARRAY OF CHAR; VAR fullname: ARRAY OF CHAR);
VAR i, j: LONGINT;
BEGIN
	i := 0; WHILE name[i] # 0X DO fullname[i] := name[i]; INC(i) END;
	j := 0; WHILE extension[j] # 0X DO fullname[i] := extension[j]; INC(i); INC(j) END;
	fullname[i] := 0X
END JoinExtension;

PROCEDURE MakeName (CONST name: ARRAY OF CHAR; VAR fullname: ARRAY OF CHAR);
BEGIN JoinExtension (name, ".arm", fullname)
END MakeName;

PROCEDURE ReadString (VAR r: OFS.Rider; VAR string: ARRAY OF CHAR);
VAR ch: CHAR; i: LONGINT;
BEGIN i := 0;
	REPEAT OFS.Read (r, ch); string[i] := ch; INC (i) UNTIL ch = 0X;
END ReadString;

PROCEDURE Fixup(pbase, fixloc, offset, base: LONGINT; CONST entry: ARRAY OF LONGINT);
	VAR instr, next, pno: LONGINT;
BEGIN
	WHILE fixloc # 0 DO
		SYSTEM.GET (pbase + fixloc*4, instr); next := instr MOD 10000H;
		pno := instr DIV 10000H MOD 100H;
		IF instr DIV 1000000H MOD 100H = 0EBH THEN  (* case  BL *)
			instr := instr DIV 1000000H * 1000000H + (entry[pno] + offset - fixloc - 2) MOD 1000000H
		(*ELSIF instr DIV 1000000H = 0 THEN (*indir. variable address*) instr := entry[pno] + base*)
		ELSE (*indir. proc. address*) instr := entry[pno]*4 + base
		END ;
		SYSTEM.PUT (pbase + fixloc*4, instr); fixloc := next
	END
END Fixup;

PROCEDURE FixSelf (pbase, fixloc, base: LONGINT);
	VAR instr, next: LONGINT;
BEGIN
	WHILE fixloc # 0 DO
		SYSTEM.GET (pbase+fixloc*4, instr); next := instr MOD 10000H;
		SYSTEM.PUT (pbase+fixloc*4, instr DIV 10000H * 4 + base); fixloc := next
	END
END FixSelf;

PROCEDURE FindModule*(CONST name: ARRAY OF CHAR; VAR m: Module);
BEGIN m := root;
	WHILE (m # NIL) & ~Strings.EqualIgnoreCase(m.name, name) DO m := m.next END;
END FindModule;

PROCEDURE Call (m: Module; entry: LONGINT);
VAR p: PROCEDURE;
BEGIN 
	SYSTEM.PUT (ADDRESSOF (p), m.pbase + entry * 4); p
END Call;

PROCEDURE CallP*(m: Module; CONST pname: ARRAY OF CHAR): BOOLEAN;
VAR cmd: Command;
BEGIN cmd := m.command;
	WHILE (cmd # NIL) & (cmd.name # pname) DO cmd := cmd.next END;
	IF cmd # NIL THEN Call (m, cmd.offset) END;
	RETURN cmd # NIL
END CallP;

PROCEDURE PrintModuleInfo*(m: Module);
BEGIN
	IF m # NIL THEN
		Log.S("Module: "); Log.SL(m.name);
		Log.SI("size", m.size);
		Log.S("dbase: "); Log.H( m.dbase); Log.L;
		Log.S("pbase: "); Log.H( m.pbase); Log.L;
		Log.MFlush(Log.normal);
	END;
END PrintModuleInfo;

(* Remove a module from the free module list *)
PROCEDURE RemoveMod(mod: Module);
VAR
	m, prevMod: Module;
BEGIN
	m := mod;
	IF m = root THEN
		root := root.next;
	ELSE
		m := root;
		REPEAT
			prevMod := m;
			m := m.next;
		UNTIL (m = NIL) OR (m = mod);
		
		IF m = mod THEN prevMod.next := m.next; END;
	END;
END RemoveMod;

PROCEDURE ThisMod* (CONST modname: ARRAY OF CHAR; VAR mod: Module);
VAR imp: Module; cmd: Command;
	nofimp, nofentries, codelen, fix, fixself, i, j, base: LONGINT;
	f: OFS.File; r: OFS.Rider; err: BOOLEAN;
	name: ARRAY 32 OF CHAR;
	key, offset, datasize: LONGINT;
	fixroot: ARRAY MaxImports OF LONGINT;
	tempMod: Module;
	dynModule: DynamicModule;
BEGIN 
	mod := root; res := OK;
	WHILE (mod # NIL) & (mod.name # modname) DO mod := mod.next; END;
	IF mod = NIL THEN  (*load*)
		MakeName (modname, name);
		f := OFS.Old(name);
		IF f = NIL THEN f:= Tools.RemoteReadFile(name); END;
		IF f = NIL THEN
			mod:=NIL; res := NOTFOUND; Strings.Copy (name, errstring);
		ELSE
			OFS.Set(r, f, 0);
			NEW(dynModule); mod := dynModule; mod.next := root; mod.refcnt := 0; root := mod;
			FOR i := 0 TO MaxImports-1 DO
				mod(DynamicModule).imports[i] := NIL;
			END;
			ReadString (r, mod.name);
			OFS.ReadInt (r, mod.key);
			OFS.ReadInt (r, fixself);
			ReadString (r, name); err := FALSE; i := 0;
			WHILE (name[0] # 0X) & (res = OK) DO
				OFS.ReadInt (r, key); OFS.ReadInt (r, fix);
				ThisMod (name, imp);
				IF imp # NIL THEN
					IF key = imp.key THEN
						dynModule.imports[i] := imp; INC (imp.refcnt); fixroot[i] := fix; INC(i)
					ELSE 
						res := WRONGKEY; Strings.Copy (name, errstring); (* RemoveMod(mod); *) mod := NIL;
					END
				END;
				ReadString (r, name);
			END;
			nofimp := i;
			IF res = OK THEN
				i := 0;
				mod.command := NIL;
				ReadString (r, name);
				WHILE name[0] # 0X DO
					NEW (cmd); cmd.next := mod.command; mod.command := cmd;
					OFS.ReadInt (r, cmd.offset); cmd.name := name; 
					ReadString (r, name);
				END;
				OFS.ReadInt (r,  nofentries); NEW (mod.entrytable); OFS.ReadInt (r, mod.entrytable.entry[0]); i := 0;
				WHILE i < nofentries DO INC(i); OFS.ReadInt(r,  mod.entrytable.entry[i]); 
				END ;
				OFS.ReadInt (r, datasize); 
				Heaps.Alloc(mod.dbase, datasize);
				base := mod.dbase; WHILE datasize # 0 DO SYSTEM.PUT (base, 0); DEC (datasize, 4); INC (base, 4) END;
				OFS.ReadInt (r, codelen); mod.size := codelen * 4; 
				Heaps.Alloc(mod.pbase, mod.size);
				base := mod.pbase; WHILE codelen # 0 DO OFS.ReadInt (r, i); SYSTEM.PUT (base, i); DEC (codelen); INC (base, 4) END;
				FixSelf(mod.pbase, fixself, mod.pbase); i := 0;
				WHILE i < nofimp DO
					offset := mod(DynamicModule).imports[i].pbase - mod.pbase;
					Fixup(mod.pbase, fixroot[i], (mod(DynamicModule).imports[i].pbase - mod.pbase) DIV 4, mod(DynamicModule).imports[i].pbase, mod(DynamicModule).imports[i].entrytable.entry); INC(i);
				END;
				FOR i := 0 TO mod.size-1 BY 4 DO
					SYSTEM.GET(mod.pbase+i*4, j);
				END;
				Kernel.CleanCache();	(* tt: Make sure the data cache is flushed *)
				Call (mod, mod.entrytable.entry[0]);
			ELSE
				(* Failed to load module, therefore remove it from the list of loaded modules *)
				RemoveMod(mod);
 			END;
			OFS.Close (f);
		END;
	END;
END ThisMod;

(* Unload a module *)
PROCEDURE Unload*(CONST name: ARRAY OF CHAR );
VAR
	m: Module;
	i: LONGINT;
BEGIN
	(* find the module by name *)
	m := root;
	WHILE (m # NIL) & ~Strings.EqualIgnoreCase(m.name, name) DO m := m.next END;
	
	IF m # NIL THEN 
		(* Module found *)
		IF m.refcnt = 0 THEN
			(* Remove module from list *)
			IF ~(m IS DynamicModule) THEN
				Log.SL("Static module cannot be removed");
			ELSE
				RemoveMod(m);
				
				i := 0;
				WHILE (i < MaxImports) & (m(DynamicModule).imports[i] # NIL) DO
					DEC(m(DynamicModule).imports[i].refcnt);
					INC(i);
				END;

				Log.S("Module "); Log.S(m.name); Log.SL(" unloaded");
			END;
		ELSE
			Log.S("Cannot unload module "); Log.S(m.name); Log.SL(": Module is imported by another module");
		END;
	ELSE
		Log.S("module "); Log.S(name); Log.SL(" not found");
	END;
END Unload;

BEGIN
	SYSTEM.GET (Platform.ModRoot, root);
	
END Modules.
