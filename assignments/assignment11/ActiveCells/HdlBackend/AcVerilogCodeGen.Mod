(**
	AUTHOR: Alexey Morozov, HighDim GmbH, 2015
	PURPOSE: Verilog HDL code generation used by ActiveCells HDL backend
*)
module AcVerilogCodeGen;

import
	HdlBackend := AcHdlBackend, Strings;

const
	Out = HdlBackend.Out;
	In = HdlBackend.In;
	Inout = HdlBackend.Inout;

type

	Cell = HdlBackend.Cell;
	Cellnet = HdlBackend.Cellnet;

	Port = HdlBackend.Port;
	HdlPort = HdlBackend.HdlPort;
	AxisPort = HdlBackend.AxisPort;
	AxiWritePort = HdlBackend.AxiWritePort;
	AxiReadPort = HdlBackend.AxiReadPort;
	CellnetPort = HdlBackend.CellnetPort;

	Channel = HdlBackend.Channel;

	Property = HdlBackend.Property;

	Integer = HdlBackend.Integer;
	Set = HdlBackend.Set;
	Real = HdlBackend.Real;
	String = HdlBackend.String;
	BinaryValue = HdlBackend.BinaryValue;

	(*
		Verilog HDL code generator
	*)
	VerilogCodeGenerator* = object(HdlBackend.HdlCodeGenerator)

		procedure &InitVerilogCodeGenerator*();
		begin
			InitObject;
		end InitVerilogCodeGenerator;

		procedure GetModuleFileExt(var ext: array of char);
		begin
			ext := ".v";
		end GetModuleFileExt;

		(* block comment *)
		procedure BlockComment*(const comment: array of char);
		begin
			Format("/*");
			Format(comment);
			Format("*/");
		end BlockComment;

		(* line comment *)
		procedure LineComment*(const comment: array of char);
		begin
			Format("//"); Format(comment);
		end LineComment;

		(**
			Start module declaration
		*)
		procedure StartModule*(c: Cell);
		begin
			BlockComment("\\HDL module automatically generated by ActiveCells IDE. \\");
			Format("\\module ");
			Format(c.hdlName^);
			Format("\\(\\");
			DeclareModulePorts0(c,true);
			Format("\\);\\")
		end StartModule;

		(* Declare an HDL parameter described by a property object *)
		procedure DeclareModuleParameter*(prop: Property);
		var c: Cell;
		begin
			c := prop.GetCell();
			if (prop.hdlName = nil) & ~(c is Cellnet) then return; end; (* do not declare purely ActiveCells parameters *)
			w.String("parameter ");
			if prop.value is Integer then
				assert((prop.value(Integer).val >= min(signed32)) & (prop.value(Integer).val <= max(signed32)));
				w.String("integer ");
				if c is Cellnet then w.String(prop.acName^);
				else w.String(prop.hdlName^);
				end;
				w.String(" = ");
			elsif prop.value is String then
				if c is Cellnet then w.String(prop.acName^);
				else w.String(prop.hdlName^);
				end;
				w.String(" = ");
			elsif prop.value is Real then
				assert((prop.value(Real).val >= min(float32)) & (prop.value(Real).val <= max(float32)));
				w.String("float32 ");
				if c is Cellnet then w.String(prop.acName^);
				else w.String(prop.hdlName^);
				end;
				w.String(" = ");
			else
				halt(100);
			end;
			prop.value.HdlPrint(w);
			w.String(";"); w.Ln;
		end DeclareModuleParameter;

		(** Declare all HDL parameters of a module described by a Cell object (to be called right after StartModule) *)
		procedure DeclareModuleParameters*(c: Cell);
		var i, n: size;
		begin
			if c.props = nil then return; end;
			n := c.props.Length();
			for i := 0 to n-1 do DeclareModuleParameter(c.props.GetProperty(i)); end;
		end DeclareModuleParameters;

		(**
			Declare a module port
		*)
		procedure DeclareModulePort*(p: Port);
		var wrote: boolean;
		begin
			DeclareModulePort0(p,false,"",wrote);
		end DeclareModulePort;

		(**
			Declare a module port with a parameterizable data width

			dataWidthParamName: parameter name defining the data width of the port
		*)
		procedure DeclareModulePortParamDataWidth*(p: Port; const dataWidthParamName: array of char);
		var wrote: boolean;
		begin
			DeclareModulePort0(p,false,dataWidthParamName,wrote);
		end DeclareModulePortParamDataWidth;

		(**
			Declare all ports of a module described by a Cell object
		*)
		procedure DeclareModulePorts*(c: Cell);
		begin
			DeclareModulePorts0(c,false);
		end DeclareModulePorts;

		(*
			name: HDL port name
			proto: prototype port; in case of a non-cellnet port conicides with the actual port
			hdlInstName: HDL name of the cell instance that owns the port
			declaringModule: TRUE if port is declared in the context of a module declaration, if FALSE in the context of an instance declaration
			declaringHeader: TRUE if declaring the port in the module/instance header
			dataWidth: data width specification string; if empty will be inferred directly from the port
			wrote: set to TRUE if the port has been written (has to be set to FALSE in the upcalling procedure)
		*)
		procedure DeclarePort(
										const name: array of char;
										proto: Port;
										const hdlInstName: array of char;
										declaringModule, declaringHeader: boolean;
										const dataWidth: array of char;
										var wrote: boolean
										);
		begin
			assert(proto.hdlName # nil);

			if (declaringModule or ~declaringHeader) & proto.unused then return; end;

			if proto is HdlPort then
				if ~declaringHeader then
					if declaringModule then
						if proto.direction = In then w.String("input ");
						elsif proto.direction = Out then w.String("output ");
						else w.String("inout ");
						end;
					else
						w.String("wire ");
					end;
					if dataWidth = "" then
						assert(proto.width >= 0);
						if proto.width > 1 then
							w.String("[" & (proto.width-1) & ":0] ");
						end;
					else
						w.String("[" & dataWidth & "-1:0] ");
					end;
					Format(name & ";\\");
				else
					if wrote then Format(",\\"); end;
					if declaringModule then w.String(name);
					else (* instance header port setting *)
						w.String("." & name & "(");
						if proto.unused then
							w.String(")");
						else
							w.String(hdlInstName & "_" & name & ")");
						end;
					end;
				end;
				wrote := true;
			elsif proto is AxisPort then

				Format("\\");
				with proto : AxisPort do
					if proto.tvalid # nil then DeclarePort(name & "_tvalid",proto.tvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tready # nil then DeclarePort(name & "_tready",proto.tready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tdata # nil then DeclarePort(name & "_tdata",proto.tdata,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tstrb # nil then DeclarePort(name & "_tstrb",proto.tstrb,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tkeep # nil then DeclarePort(name & "_tkeep",proto.tkeep,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tlast # nil then DeclarePort(name & "_tlast",proto.tlast,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tid # nil then DeclarePort(name & "_tid",proto.tid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tdest # nil then DeclarePort(name & "_tdest",proto.tdest,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.tuser # nil then DeclarePort(name & "_tuser",proto.tuser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
				end;
			elsif proto is AxiWritePort then

				Format("\\");
				with proto: AxiWritePort do
					if proto.awid # nil then DeclarePort(name & "_awid",proto.awid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awaddr # nil then DeclarePort(name & "_awaddr",proto.awaddr,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awlen # nil then DeclarePort(name & "_awlen",proto.awlen,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awsize # nil then DeclarePort(name & "_awsize",proto.awsize,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awburst # nil then DeclarePort(name & "_awburst",proto.awburst,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awlock # nil then DeclarePort(name & "_awlock",proto.awlock,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awcache # nil then DeclarePort(name & "_awcache",proto.awcache,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awprot # nil then DeclarePort(name & "_awprot",proto.awprot,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awqos # nil then DeclarePort(name & "_awqos",proto.awqos,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awregion # nil then DeclarePort(name & "_awregion",proto.awregion,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awuser # nil then DeclarePort(name & "_awuser",proto.awuser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awvalid # nil then DeclarePort(name & "_awvalid",proto.awvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.awready # nil then DeclarePort(name & "_awready",proto.awready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;

					if proto.wid # nil then DeclarePort(name & "_wid",proto.wid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wdata # nil then DeclarePort(name & "_wdata",proto.wdata,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wstrb # nil then DeclarePort(name & "_wstrb",proto.wstrb,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wlast # nil then DeclarePort(name & "_wlast",proto.wlast,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wuser # nil then DeclarePort(name & "_wuser",proto.wuser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wvalid # nil then DeclarePort(name & "_wvalid",proto.wvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.wready # nil then DeclarePort(name & "_wready",proto.wready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;

					if proto.bid # nil then DeclarePort(name & "_bid",proto.bid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.bresp # nil then DeclarePort(name & "_bresp",proto.bresp,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.buser # nil then DeclarePort(name & "_buser",proto.buser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.bvalid # nil then DeclarePort(name & "_bvalid",proto.bvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.bready # nil then DeclarePort(name & "_bready",proto.bready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
				end;

			elsif proto is AxiReadPort then

				Format("\\");
				with proto: AxiReadPort do
					if proto.arid # nil then DeclarePort(name & "_arid",proto.arid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.araddr # nil then DeclarePort(name & "_araddr",proto.araddr,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arlen # nil then DeclarePort(name & "_arlen",proto.arlen,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arsize # nil then DeclarePort(name & "_arsize",proto.arsize,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arburst # nil then DeclarePort(name & "_arburst",proto.arburst,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arlock # nil then DeclarePort(name & "_arlock",proto.arlock,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arcache # nil then DeclarePort(name & "_arcache",proto.arcache,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arprot # nil then DeclarePort(name & "_arprot",proto.arprot,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arqos # nil then DeclarePort(name & "_arqos",proto.arqos,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arregion # nil then DeclarePort(name & "_arregion",proto.arregion,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.aruser # nil then DeclarePort(name & "_aruser",proto.aruser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arvalid # nil then DeclarePort(name & "_arvalid",proto.arvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.arready # nil then DeclarePort(name & "_arready",proto.arready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;

					if proto.rid # nil then DeclarePort(name & "_rid",proto.rid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.rdata # nil then DeclarePort(name & "_rdata",proto.rdata,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.rresp # nil then DeclarePort(name & "_rresp",proto.rresp,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.rlast # nil then DeclarePort(name & "_rlast",proto.rlast,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.ruser # nil then DeclarePort(name & "_ruser",proto.ruser,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.rvalid # nil then DeclarePort(name & "_rvalid",proto.rvalid,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
					if proto.rready # nil then DeclarePort(name & "_rready",proto.rready,hdlInstName,declaringModule,declaringHeader,"",wrote); end;
				end;

			else
				halt(100);
			end;
		end DeclarePort;

		procedure DeclareModulePort0(p: Port; declaringHeader: boolean; const dataWidth: array of char; var wrote: boolean);
		begin
			if p is CellnetPort then
				DeclarePort(p.hdlName^,p(CellnetPort).protoPort,"",true,declaringHeader,dataWidth,wrote);
			else
				DeclarePort(p.hdlName^,p,"",true,declaringHeader,dataWidth,wrote);
			end;
		end DeclareModulePort0;

		procedure DeclareModulePorts0(c: Cell; declaringHeader: boolean);
		var
			i, n: size;
			wrote: boolean;
		begin
			if c.ports = nil then return; end;
			n := c.ports.Length();
			for i := 0 to n-1 do
				DeclareModulePort0(c.ports.GetPort(i),declaringHeader,"",wrote);
				if declaringHeader then
					wrote := false;
					if i < n-1 then Format(",\\"); end;
				end;
			end;
		end DeclareModulePorts0;

		(**
			Declare a module described by a Cell object

			Module declaration includes:
				- module name
				- module header with the list of all port names
				- module parameters
				- declaration of module ports corresponding to the port names in the header
		*)
		procedure DeclareModule*(c: Cell);
		begin
			StartModule(c);
			if c.props # nil then
				Format("\\");
				BlockComment("\\Module parameters\\");
				Format("\\");
				DeclareModuleParameters(c);
			end;
			Format("\\");
			BlockComment("\\Module ports\\");
			Format("\\");
			DeclareModulePorts(c);
			Format("\\");
		end DeclareModule;

		(** Module end *)
		procedure EndModule*();
		begin
			Format("endmodule\\");
		end EndModule;

		(* Write name of a cell instance port

			hdlName: HDL name of the port
			hdlInstName: HDL name of the cell instance that owns the port
		*)
		procedure WriteInstancePortName*(const hdlName, hdlInstName: array of char);
		begin
			w.String(hdlInstName); w.String("_"); w.String(hdlName);
		end WriteInstancePortName;

		(** Declare a cell instance port including all its nets *)
		procedure DeclareInstancePort*(p: Port; const hdlInstName: array of char);
		begin
			DeclareInstancePort0(p,hdlInstName,"");
		end DeclareInstancePort;

		(** Declare a cell instance port including all its nets

			hdlInstName: HDL name of the cell instance
			dataWidthParamName: parameter name defining the data width of the port
		*)
		procedure DeclareInstancePortParamDataWidth*(p: Port; const hdlInstName: array of char; const dataWidthParamName: array of char);
		begin
			DeclareInstancePort0(p,hdlInstName,dataWidthParamName);
		end DeclareInstancePortParamDataWidth;

		(* Declare a cell instance port including all its nets *)
		procedure DeclareInstancePort0(p: Port; const hdlInstName: array of char; const dataWidth: array of char);
		var wrote: boolean;
		begin
			if p is CellnetPort then
				DeclarePort(hdlInstName & "_" & p.hdlName^,p(CellnetPort).protoPort,hdlInstName,false,false,dataWidth,wrote);
			else
				DeclarePort(hdlInstName & "_" & p.hdlName^,p,hdlInstName,false,false,dataWidth,wrote);
			end;
		end DeclareInstancePort0;

		(* Set cell instance property *)
		procedure SetInstProperty(prop: Property);
		begin
			w.Char(".");
			if prop.hdlName # nil then w.String(prop.hdlName^);
			else w.String(prop.acName^); (*! temporary! *)
			end;
			w.Char("(");
			prop.value.HdlPrint(w);
			w.Char(")");
		end SetInstProperty;

		(** Set nets for a cell instance port *)
		procedure SetInstancePort*(p: Port; const hdlInstName: array of char);
		var wrote: boolean;
		begin
			if p is CellnetPort then
				DeclarePort(p.hdlName^,p(CellnetPort).protoPort,hdlInstName,false,true,"",wrote);
			else
				DeclarePort(p.hdlName^,p,hdlInstName,false,true,"",wrote);
			end;
			assert(wrote);
		end SetInstancePort;

		(** Set nets for all ports of a cell instance *)
		procedure SetInstancePorts*(c: Cell; const hdlInstName: array of char);
		var i, n: size;
		begin
			if c.ports = nil then return; end;
			n := c.ports.Length();
			for i := 0 to n-1 do
				SetInstancePort(c.ports.GetPort(i),hdlInstName);
				if i < n-1 then Format(",\\"); else Format("\\"); end;
			end;
		end SetInstancePorts;

		procedure AssignPort*(
										srcPort, dstPort: Port;
										scopeCell: Cell
										);
		var
			sp, dp: Port;
			sName, dName: HdlBackend.LongString;

			procedure Assign(const srcName, dstName: array of char; srcProto, dstProto: Port);
			begin
				if srcProto is HdlPort then
					assert(dstProto is HdlPort);
					Format("assign " & dstName & " = " & srcName & ";\\");
				elsif srcProto is AxisPort then
					assert(dstProto is AxisPort);
					with srcProto : AxisPort do
						with dstProto : AxisPort do
							if srcProto.tvalid # nil then Assign(srcName & "_tvalid",dstName & "_tvalid",srcProto.tvalid,dstProto.tvalid); end;
							if srcProto.tready # nil then Assign(dstName & "_tready",srcName & "_tready",srcProto.tready,dstProto.tready); end;
							if srcProto.tdata # nil then Assign(srcName & "_tdata",dstName & "_tdata",srcProto.tdata,dstProto.tdata); end;
							if srcProto.tstrb # nil then Assign(srcName & "_tstrb",dstName & "_tstrb",srcProto.tstrb,dstProto.tstrb); end;
							if srcProto.tkeep # nil then Assign(srcName & "_tkeep",dstName & "_tkeep",srcProto.tkeep,dstProto.tkeep); end;
							if srcProto.tlast # nil then Assign(srcName & "_tlast",dstName & "_tlast",srcProto.tlast,dstProto.tlast); end;
							if srcProto.tid # nil then Assign(srcName & "_tid",dstName & "_tid",srcProto.tid,dstProto.tid); end;
							if (srcProto.tdest # nil) & (dstProto.tdest # nil) then
								if srcProto.tdest.direction = Out then (* src is master *)
									Assign(srcName & "_tdest",dstName & "_tdest",srcProto.tdest,dstProto.tdest);
								else (* dst is master *)
									assert(dstProto.tdest.direction = Out);
									Assign(dstName & "_tdest",srcName & "_tdest",dstProto.tdest,srcProto.tdest);
								end;
							end;
							if srcProto.tuser # nil then
								assert(dstProto.tuser # nil);
								Assign(srcName & "_tuser",dstName & "_tuser",srcProto.tuser,dstProto.tuser);
							end;
						end;
					end;
				elsif srcProto is AxiWritePort then
					if dstProto is CellnetPort then dstProto := dstProto(CellnetPort).protoPort; end;
					assert(dstProto is AxiWritePort);
					with srcProto : AxiWritePort do
						with dstProto : AxiWritePort do
							if srcProto.awid # nil then Assign(srcName & "_awid",dstName & "_awid",srcProto.awid,dstProto.awid); end;
							if srcProto.awaddr # nil then Assign(srcName & "_awaddr",dstName & "_awaddr",srcProto.awaddr,dstProto.awaddr); end;
							if srcProto.awlen # nil then Assign(srcName & "_awlen",dstName & "_awlen",srcProto.awlen,dstProto.awlen); end;
							if srcProto.awsize # nil then Assign(srcName & "_awsize",dstName & "_awsize",srcProto.awsize,dstProto.awsize); end;
							if srcProto.awburst # nil then Assign(srcName & "_awburst",dstName & "_awburst",srcProto.awburst,dstProto.awburst); end;
							if srcProto.awlock # nil then Assign(srcName & "_awlock",dstName & "_awlock",srcProto.awlock,dstProto.awlock); end;
							if srcProto.awcache # nil then Assign(srcName & "_awcache",dstName & "_awcache",srcProto.awcache,dstProto.awcache); end;
							if srcProto.awprot # nil then Assign(srcName & "_awprot",dstName & "_awprot",srcProto.awprot,dstProto.awprot); end;
							if srcProto.awqos # nil then Assign(srcName & "_awqos",dstName & "_awqos",srcProto.awqos,dstProto.awqos); end;
							if srcProto.awregion # nil then Assign(srcName & "_awregion",dstName & "_awregion",srcProto.awregion,dstProto.awregion); end;
							if srcProto.awuser # nil then Assign(srcName & "_awuser",dstName & "_awuser",srcProto.awuser,dstProto.awuser); end;
							if srcProto.awvalid # nil then Assign(srcName & "_awvalid",dstName & "_awvalid",srcProto.awvalid,dstProto.awvalid); end;
							if srcProto.awready # nil then Assign(dstName & "_awready",srcName & "_awready",dstProto.awready,srcProto.awready); end;

							if srcProto.wid # nil then Assign(srcName & "_wid",dstName & "_wid",srcProto.wid,dstProto.wid); end;
							if srcProto.wdata # nil then Assign(srcName & "_wdata",dstName & "_wdata",srcProto.wdata,dstProto.wdata); end;
							if srcProto.wstrb # nil then Assign(srcName & "_wstrb",dstName & "_wstrb",srcProto.wstrb,dstProto.wstrb); end;
							if srcProto.wlast # nil then Assign(srcName & "_wlast",dstName & "_wlast",srcProto.wlast,dstProto.wlast); end;
							if srcProto.wuser # nil then Assign(srcName & "_wuser",dstName & "_wuser",srcProto.wuser,dstProto.wuser); end;
							if srcProto.wvalid # nil then Assign(srcName & "_wvalid",dstName & "_wvalid",srcProto.wvalid,dstProto.wvalid); end;
							if srcProto.wready # nil then Assign(dstName & "_wready",srcName & "_wready",dstProto.wready,srcProto.wready); end;

							if srcProto.bid # nil then Assign(dstName & "_bid",srcName & "_bid",dstProto.bid,srcProto.bid); end;
							if srcProto.bresp # nil then Assign(dstName & "_bresp",srcName & "_bresp",dstProto.bresp,srcProto.bresp); end;
							if srcProto.buser # nil then Assign(dstName & "_buser",srcName & "_buser",dstProto.buser,srcProto.buser); end;
							if srcProto.bvalid # nil then Assign(dstName & "_bvalid",srcName & "_bvalid",dstProto.bvalid,srcProto.bvalid); end;
							if srcProto.bready # nil then Assign(srcName & "_bready",dstName & "_bready",srcProto.bready,dstProto.bready); end;
						end;
					end;
				elsif srcProto is AxiReadPort then
					if dstProto is CellnetPort then dstProto := dstProto(CellnetPort).protoPort; end;
					assert(dstProto is AxiReadPort);
					with srcProto : AxiReadPort do
						with dstProto : AxiReadPort do
							if srcProto.arid # nil then Assign(srcName & "_arid",dstName & "_arid",srcProto.arid,dstProto.arid); end;
							if srcProto.araddr # nil then Assign(srcName & "_araddr",dstName & "_araddr",srcProto.araddr,dstProto.araddr); end;
							if srcProto.arlen # nil then Assign(srcName & "_arlen",dstName & "_arlen",srcProto.arlen,dstProto.arlen); end;
							if srcProto.arsize # nil then Assign(srcName & "_arsize",dstName & "_arsize",srcProto.arsize,dstProto.arsize); end;
							if srcProto.arburst # nil then Assign(srcName & "_arburst",dstName & "_arburst",srcProto.arburst,dstProto.arburst); end;
							if srcProto.arlock # nil then Assign(srcName & "_arlock",dstName & "_arlock",srcProto.arlock,dstProto.arlock); end;
							if srcProto.arcache # nil then Assign(srcName & "_arcache",dstName & "_arcache",srcProto.arcache,dstProto.arcache); end;
							if srcProto.arprot # nil then Assign(srcName & "_arprot",dstName & "_arprot",srcProto.arprot,dstProto.arprot); end;
							if srcProto.arqos # nil then Assign(srcName & "_arqos",dstName & "_arqos",srcProto.arqos,dstProto.arqos); end;
							if srcProto.arregion # nil then Assign(srcName & "_arregion",dstName & "_arregion",srcProto.arregion,dstProto.arregion); end;
							if srcProto.aruser # nil then Assign(srcName & "_aruser",dstName & "_aruser",srcProto.aruser,dstProto.aruser); end;
							if srcProto.arvalid # nil then Assign(srcName & "_arvalid",dstName & "_arvalid",srcProto.arvalid,dstProto.arvalid); end;
							if srcProto.arready # nil then Assign(dstName & "_arready",srcName & "_arready",dstProto.arready,srcProto.arready); end;

							if srcProto.rid # nil then Assign(dstName & "_rid",srcName & "_rid",dstProto.rid,srcProto.rid); end;
							if srcProto.rdata # nil then Assign(dstName & "_rdata",srcName & "_rdata",dstProto.rdata,srcProto.rdata); end;
							if srcProto.rresp # nil then Assign(dstName & "_rresp",srcName & "_rresp",dstProto.rresp,srcProto.rresp); end;
							if srcProto.rlast # nil then Assign(dstName & "_rlast",srcName & "_rlast",dstProto.rlast,srcProto.rlast); end;
							if srcProto.ruser # nil then Assign(dstName & "_ruser",srcName & "_ruser",dstProto.ruser,srcProto.ruser); end;
							if srcProto.rvalid # nil then Assign(dstName & "_rvalid",srcName & "_rvalid",dstProto.rvalid,srcProto.rvalid); end;
							if srcProto.rready # nil then Assign(srcName & "_rready",dstName & "_rready",srcProto.rready,dstProto.rready); end;
						end;
					end;
				else
					halt(100);
				end;
			end Assign;

		begin
			if srcPort is CellnetPort then sp := srcPort(CellnetPort).protoPort; else sp := srcPort; end;
			if dstPort is CellnetPort then dp := dstPort(CellnetPort).protoPort; else dp := dstPort; end;
			assert(~(sp is CellnetPort));
			assert(~(dp is CellnetPort));
			if srcPort.GetCell() = scopeCell then copy(srcPort.hdlName^,sName);
			else sName := srcPort.GetCell().hdlInstName^ & "_" & srcPort.hdlName^; end;
			if dstPort.GetCell() = scopeCell then copy(dstPort.hdlName^,dName);
			else dName := dstPort.GetCell().hdlInstName^ & "_" & dstPort.hdlName^; end;
			(*!TODO: double check that ports are going to be assigned correctly (in the right directions) *)
			Assign(sName,dName,sp,dp);
		end AssignPort;
(*
		(**
			Assigns nets corresponding to given source and destination ports

			dstPortIsTerminal: TRUE in case if destination net port is a terminal of the current module; in this case net naming will be different from an instance port net name
			srcPortIsTerminal: TRUE in case if source net port is a terminal of the current module; in this case net naming will be different from an instance port net name
		*)
		procedure AssignPort0*(
										srcPort, dstPort: Port;
										const srcHdlInstName, dstHdlInstName: array of char;
										srcPortIsTerminal, dstPortIsTerminal: boolean
										);
		begin
			if srcPort is HdlPort then
				if dstPort is CellnetPort then dstPort := dstPort(CellnetPort).protoPort; end;
				assert(dstPort is HdlPort);
				w.String("assign ");
				if dstPort(HdlPort).isExternal & (dstPort.direction # In) then (* handle external ports *)
					assert(srcPort(HdlPort).isExternal);
					w.String("ext_"); WriteInstancePortName(dstPort.hdlName^,dstPort.GetCell().hdlInstName^);
				elsif ~dstPortIsTerminal then WriteInstancePortName(dstPort.hdlName^,dstHdlInstName);
				else w.String(dstPort.hdlName^);
				end;
				w.String(" = ");
				(*assert(((dstPort(HdlPort).signalPolarity # nil) & (srcPort(HdlPort).signalPolarity # nil)) or ((dstPort(HdlPort).signalPolarity = nil) & (srcPort(HdlPort).signalPolarity = nil)));
				if dstPort(HdlPort).signalPolarity # nil then
					halt(777);
				end;*)

				if srcPort(HdlPort).isExternal & (srcPort.direction = In) then (* handle external ports *)
					assert(dstPort(HdlPort).isExternal);
					w.String("ext_"); WriteInstancePortName(srcPort.hdlName^,srcPort.GetCell().hdlInstName^);
				elsif ~srcPortIsTerminal then WriteInstancePortName(srcPort.hdlName^,srcHdlInstName);
				else w.String(srcPort.hdlName^);
				end;

				Format(";\\");
			elsif srcPort is AxisPort then
				if dstPort is CellnetPort then dstPort := dstPort(CellnetPort).protoPort; end;
				assert(dstPort is AxisPort);
				with srcPort : AxisPort do
					with dstPort : AxisPort do
						if srcPort.tvalid # nil then AssignPort0(srcPort.tvalid,dstPort.tvalid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.tready # nil then AssignPort0(dstPort.tready,srcPort.tready,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.tdata # nil then AssignPort0(srcPort.tdata,dstPort.tdata,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.tstrb # nil then AssignPort0(srcPort.tstrb,dstPort.tstrb,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.tkeep # nil then AssignPort0(srcPort.tkeep,dstPort.tkeep,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.tlast # nil then AssignPort0(srcPort.tlast,dstPort.tlast,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.tid # nil then AssignPort0(srcPort.tid,dstPort.tid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if (srcPort.tdest # nil) & (dstPort.tdest # nil) then
							if srcPort.tdest.direction = Out then (* src is master *)
								AssignPort0(srcPort.tdest,dstPort.tdest,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal);
							else (* dst is master *)
								assert(dstPort.tdest.direction = Out);
								AssignPort0(dstPort.tdest,srcPort.tdest,dstHdlInstName,srcHdlInstName,srcPortIsTerminal,dstPortIsTerminal);
							end;
						end;
						if srcPort.tuser # nil then
							assert(dstPort.tuser # nil);
							AssignPort0(srcPort.tuser,dstPort.tuser,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal);
						end;
					end
				end;
			elsif srcPort is AxiWritePort then
				if dstPort is CellnetPort then dstPort := dstPort(CellnetPort).protoPort; end;
				assert(dstPort is AxiWritePort);
				with srcPort : AxiWritePort do
					with dstPort : AxiWritePort do
						if srcPort.awid # nil then AssignPort0(srcPort.awid,dstPort.awid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awaddr # nil then AssignPort0(srcPort.awaddr,dstPort.awaddr,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awlen # nil then AssignPort0(srcPort.awlen,dstPort.awlen,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awsize # nil then AssignPort0(srcPort.awsize,dstPort.awsize,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awburst # nil then AssignPort0(srcPort.awburst,dstPort.awburst,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awlock # nil then AssignPort0(srcPort.awlock,dstPort.awlock,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awcache # nil then AssignPort0(srcPort.awcache,dstPort.awcache,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awprot # nil then AssignPort0(srcPort.awprot,dstPort.awprot,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awqos # nil then AssignPort0(srcPort.awqos,dstPort.awqos,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awregion # nil then AssignPort0(srcPort.awregion,dstPort.awregion,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awuser # nil then AssignPort0(srcPort.awuser,dstPort.awuser,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awvalid # nil then AssignPort0(srcPort.awvalid,dstPort.awvalid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.awready # nil then AssignPort0(dstPort.awready,srcPort.awready,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;

						if srcPort.wid # nil then AssignPort0(srcPort.wid,dstPort.wid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wdata # nil then AssignPort0(srcPort.wdata,dstPort.wdata,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wstrb # nil then AssignPort0(srcPort.wstrb,dstPort.wstrb,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wlast # nil then AssignPort0(srcPort.wlast,dstPort.wlast,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wuser # nil then AssignPort0(srcPort.wuser,dstPort.wuser,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wvalid # nil then AssignPort0(srcPort.wvalid,dstPort.wvalid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.wready # nil then AssignPort0(dstPort.wready,srcPort.wready,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;

						if srcPort.bid # nil then AssignPort0(dstPort.bid,srcPort.bid,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.bresp # nil then AssignPort0(dstPort.bresp,srcPort.bresp,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.buser # nil then AssignPort0(dstPort.buser,srcPort.buser,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.bvalid # nil then AssignPort0(dstPort.bvalid,srcPort.bvalid,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.bready # nil then AssignPort0(srcPort.bready,dstPort.bready,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
					end;
				end;
			elsif srcPort is AxiReadPort then
				if dstPort is CellnetPort then dstPort := dstPort(CellnetPort).protoPort; end;
				assert(dstPort is AxiReadPort);
				with srcPort : AxiReadPort do
					with dstPort : AxiReadPort do
						if srcPort.arid # nil then AssignPort0(srcPort.arid,dstPort.arid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.araddr # nil then AssignPort0(srcPort.araddr,dstPort.araddr,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arlen # nil then AssignPort0(srcPort.arlen,dstPort.arlen,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arsize # nil then AssignPort0(srcPort.arsize,dstPort.arsize,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arburst # nil then AssignPort0(srcPort.arburst,dstPort.arburst,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arlock # nil then AssignPort0(srcPort.arlock,dstPort.arlock,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arcache # nil then AssignPort0(srcPort.arcache,dstPort.arcache,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arprot # nil then AssignPort0(srcPort.arprot,dstPort.arprot,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arqos # nil then AssignPort0(srcPort.arqos,dstPort.arqos,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arregion # nil then AssignPort0(srcPort.arregion,dstPort.arregion,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.aruser # nil then AssignPort0(srcPort.aruser,dstPort.aruser,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arvalid # nil then AssignPort0(srcPort.arvalid,dstPort.arvalid,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
						if srcPort.arready # nil then AssignPort0(dstPort.arready,srcPort.arready,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;

						if srcPort.rid # nil then AssignPort0(dstPort.rid,srcPort.rid,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.rdata # nil then AssignPort0(dstPort.rdata,srcPort.rdata,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.rresp # nil then AssignPort0(dstPort.rresp,srcPort.rresp,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.rlast # nil then AssignPort0(dstPort.rlast,srcPort.rlast,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.ruser # nil then AssignPort0(dstPort.ruser,srcPort.ruser,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.rvalid # nil then AssignPort0(dstPort.rvalid,srcPort.rvalid,dstHdlInstName,srcHdlInstName,dstPortIsTerminal,srcPortIsTerminal); end;
						if srcPort.rready # nil then AssignPort0(srcPort.rready,dstPort.rready,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal); end;
					end;
				end;
			elsif srcPort is CellnetPort then
				srcPort := srcPort(CellnetPort).protoPort;
				if dstPort is CellnetPort then dstPort := dstPort(CellnetPort).protoPort; end;
				AssignPort0(srcPort,dstPort,srcHdlInstName,dstHdlInstName,srcPortIsTerminal,dstPortIsTerminal);
			else
				halt(100);
			end;
		end AssignPort0;
*)
		(**
			Declare a register

			name: register name
			width: string specification of the register width
		*)
		procedure DeclareRegister*(const name, width: array of char);
		begin
			assert((width # "") & (width # "0"));
			if width # "1" then
				Format("reg " & "[" & width & "-1:0] " & name & ";\\");
			else
				Format("reg " & name & ";\\");
			end;
		end DeclareRegister;

		(**
			Declare a net

			name: net name
			width: string specification of the net width
		*)
		procedure DeclareNet*(const name, width: array of char);
		begin
			assert((width # "") & (width # "0"));
			if width # "1" then
				Format("wire " & "[" & width & "-1:0] " & name & ";\\");
			else
				Format("wire " & name & ";\\");
			end;
		end DeclareNet;

		(**
			Declare a net and assign it to a specified value

			name: net name
			width: string specification of the net width
			value: string specification of the net assignment value
		*)
		procedure DeclareAndAssignNet*(const name, width, value: array of char);
		begin
			assert((width # "") & (width # "0"));
			if width # "1" then
				Format("wire " & "[" & width & "-1:0] " & name);
			else
				Format("wire " & name);
			end;
			Format(" = " & value & ";\\");
		end DeclareAndAssignNet;

		(**
			Declare a local parameter

			name: parameter name
			paramType: string specification of parameter type (can be an empty string)
			value: string specification of the parameter value
		*)
		procedure DeclareLocalParam*(const name, paramType, value: array of char);
		begin
			assert(value # "");
			Format("localparam " & paramType & " " & name & " = " & value & ";\\");
		end DeclareLocalParam;

		procedure InstantiateCell(c: Cell; const hdlInstName: array of char);
		var
			i, m, n: size;
			wrote: boolean;
			prop: Property;
		begin
			if c.acInstName # nil then BlockComment(c.acInstName^); Format("\\"); end;

			if c.ports # nil then
				n := c.ports.Length();
				for i := 0 to n-1 do DeclareInstancePort0(c.ports.GetPort(i),hdlInstName,""); end;
			end;
			Format("\\");

			w.String(c.hdlName^);

			(* write instance parameters *)
			if c.props # nil then
				n := c.props.Length();
				m := 0;
				for i := 0 to n-1 do
					prop := c.props.GetProperty(i);
					if (prop.hdlName # nil) or (c is Cellnet) then inc(m); end;
				end;
				if m > 0 then (*! avoid empty parameter assignment - causes an error in ISE *)
					Format("\\#(\\");
					for i := 0 to n-1 do
						prop := c.props.GetProperty(i);
						if (prop.hdlName # nil) or (c is Cellnet) then (*! temporary (c is Cellnet) *)
							if wrote then Format(",\\"); end;
							SetInstProperty(prop); wrote := true;
						end;
					end;
					Format("\\)\\");
				else
					w.Char(" ");
				end;
			else
				w.Char(" ");
			end;

			(* instance name *)
			w.String(hdlInstName); Format("\\");

			(* write instance ports *)
			Format("(\\");
			SetInstancePorts(c,hdlInstName);
			Format(");\\"); Format("\\");
		end InstantiateCell;

		(*
			Generate HDL code for a cellnet
		*)
		procedure GenerateCellnetCode(net: Cellnet): boolean;
		var
			i, n: size;
			chan: Channel;
			p: Port;
			c: Cell;

			procedure AssignCellnetPorts(ports: HdlBackend.PortList);
			var
				p, p1: Port;
				k: size;
			begin
				n := ports.Length();
				for i := 0 to n-1 do
					p := ports.GetPort(i);
					assert(~p.unused);
					if p.direction # In then
						assert(p(CellnetPort).delegatedTo.Length()=1);
						p1 := p(CellnetPort).delegatedTo.GetPort(0);
						if ~(HdlBackend.FlagSkipImplementation in p1.GetCell().flags) then
							AssignPort(p1,p,net); (*AssignPort(p1,p,p1.GetCell().hdlInstName^,"",false,true);*)
							if ~(p(CellnetPort).protoPort is HdlPort) then Format("\\"); end; (* do not group simple HDL ports *)
						end;
					else
						for k := 0 to p(CellnetPort).delegatedTo.Length()-1 do
							p1 := p(CellnetPort).delegatedTo.GetPort(k);
							if ~(HdlBackend.FlagSkipImplementation in p1.GetCell().flags) then
								assert(~p1.unused);
								AssignPort(p,p1,net); (*AssignPort(p,p1,"",p1.GetCell().hdlInstName^,true,false);*)
								if ~(p(CellnetPort).protoPort is HdlPort) then Format("\\"); end; (* do not group simple HDL ports *)
							end;
						end;
					end;
				end;
			end AssignCellnetPorts;

		begin
			DeclareModule(net);

			n := net.children.Length();
			for i := 0 to n-1 do
				c := net.children.GetCell(i);
				if ~(HdlBackend.FlagSkipImplementation in c.flags) then
					InstantiateCell(c,c.hdlInstName^);
				end;
			end;

			(*
				port connections
			*)
			n := net.channels.Length();
			if n > 0 then
				BlockComment("\\Port connections\\"); Format("\\");
				for i := 0 to n-1 do
					chan := net.channels.GetChannel(i);
					assert(chan.depth = 0);
					assert((chan.outPort.direction = Out) or (chan.outPort.direction = Inout));
					assert((chan.inPort.direction = In) or (chan.inPort.direction = Inout));
					AssignPort(chan.outPort,chan.inPort,net); (*AssignPort(chan.outPort,chan.inPort,chan.outPort.GetCell().hdlInstName^,chan.inPort.GetCell().hdlInstName^,false,false);*)

					if chan.outPort is CellnetPort then p := chan.outPort(CellnetPort).protoPort; else p := chan.outPort; end;
					if ~(p is HdlPort) then Format("\\"); end; (* do not group simple HDL ports *)
				end;
			end;

			(*
				Cellnet port assignments
			*)
			assert(net.clockInputs = nil);
			assert(net.clockOutputs = nil);
			if (net.inputs # nil) or (net.outputs # nil) or (net.inoutputs # nil) then
				BlockComment("\\Cellnet port delegations\\"); Format("\\");
				if net.inputs # nil then AssignCellnetPorts(net.inputs); end;
				if net.outputs # nil then AssignCellnetPorts(net.outputs); end;
				if net.inoutputs # nil then AssignCellnetPorts(net.inoutputs); end;
			end;

			Format("\\");
			EndModule;

			w.Update;
			return true;
		finally
			w.Update;
			return false;
		end GenerateCellnetCode;

	end VerilogCodeGenerator;

var

	procedure GetGenerator*(): any;
	var gen: VerilogCodeGenerator;
	begin
		new(gen);
		return gen;
	end GetGenerator;

end AcVerilogCodeGen.
