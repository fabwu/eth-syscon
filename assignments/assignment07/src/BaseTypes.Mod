(* Runtime support for basic pointer types *)
(* Copyright (C) Florian Negele *)

(** Contains the representation of the basic pointer types of Active Oberon and the meta data associated with them. *)
(** Objects are segmented into separate data structures in order to save memory because not all objects are active or need a monitor at runtime. *)
MODULE BaseTypes;

IMPORT Counters, Queues;

(** Represents a type descriptor. *)
TYPE Descriptor* = POINTER {UNSAFE} TO RECORD
	parent- {UNTRACED}: Descriptor;
	size-: SIZE; (* or base record descriptor for arrays *)
	trace-: PROCEDURE(this: ADDRESS);
	(* method table -- filled in by the compiler *)
END;

(** Represents a pointer type. *)
TYPE Pointer* = OBJECT {DISPOSABLE,PLAIN}

	VAR descriptor- {UNTRACED}: Descriptor; (* stores the address of the type descriptor *)
	VAR cycle* := 0: LONGINTEGER; (* stores the last garbage collection cycle which reached the pointer *)
	VAR references*: Counters.Counter; (* counts how many times the pointer is referenced by local variables *)
	VAR nextMarked* {UNTRACED} := NIL: Pointer; (* stores the next item in the linked list of marked pointers *)
	VAR nextWatched* {UNTRACED} := NIL: Pointer; (* stores the next item in the linked list of watched pointers *)

	PROCEDURE Trace-;
	BEGIN {UNCOOPERATIVE, UNCHECKED}
	END Trace;

END Pointer;

(** Represents an array type. *)
TYPE Array* = OBJECT {DISPOSABLE,PLAIN} (Pointer)

	VAR length: SIZE;
	VAR data: ADDRESS;
	VAR descriptor {UNTRACED}: Descriptor;

END Array;

(** Represents an array of pointer type. *)
TYPE PointerArray* = OBJECT {DISPOSABLE,PLAIN} (Array)

	PROCEDURE Trace-;
	PROCEDURE MarkPointerArray (length: SIZE; address: ADDRESS) EXTERN "GarbageCollector.MarkPointerArray";
	BEGIN {UNCOOPERATIVE, UNCHECKED}
		MarkPointerArray (length, data);
	END Trace;

END PointerArray;

(** Represents an array of record type. *)
TYPE RecordArray* = OBJECT {DISPOSABLE,PLAIN} (Array)

	PROCEDURE Trace-;
	PROCEDURE MarkRecordArray (address: ADDRESS; length: SIZE; descriptor {UNTRACED}: Descriptor) EXTERN "GarbageCollector.MarkRecordArray" ;
	BEGIN {UNCOOPERATIVE, UNCHECKED}
		MarkRecordArray (data, length, descriptor);
	END Trace;

END RecordArray;

TYPE DelegateArray* = OBJECT {DISPOSABLE,PLAIN} (Array)

	PROCEDURE Trace-;
	PROCEDURE MarkDelegateArray (length: SIZE; address: ADDRESS) EXTERN "GarbageCollector.MarkDelegateArray" ;
	BEGIN {UNCOOPERATIVE, UNCHECKED}
		MarkDelegateArray (length, data);
	END Trace;

END DelegateArray;

(** Represents a record type. *)
TYPE Record* = OBJECT {DISPOSABLE,PLAIN} (Pointer)

	(* required fields for layout-compatibility with objects extending pointer to records *)
	VAR action: ADDRESS;
	VAR monitor: ADDRESS;

END Record;

(** Represents the meta data for an active object. *)
TYPE Action* = RECORD
	activity* {UNTRACED}: OBJECT; (* stores the activity associated with the active object *)
	waitingQueue*: Queues.Queue; (* stores all activities that are waiting inside a wait statement *)
END;

(** Represents the monitor associated with an object that has procedures with exclusive regions. *)
TYPE Monitor* = RECORD
	owner* {UNTRACED} := NIL: OBJECT; (* stores the current activity that has exclusive access *)
	nestingLevel* := 0: SIZE; (* counts how many times the same activity has acquired the monitor *)
	blockedQueue*: Queues.Queue; (* stores all activities that failed to acquire the monitor *)
	waitingQueue*: Queues.Queue; (* stores all activities that are waiting inside an await statement *)
	waitingSentinel* {UNTRACED} := NIL: OBJECT; (* stores the oldest activity waiting in the await statement *)
END;

(** Represents the basic object type. *)
TYPE Object* = OBJECT {DISPOSABLE,PLAIN} (Pointer)

	VAR action-: POINTER {UNSAFE} TO Action;
	VAR monitor-: POINTER {UNSAFE} TO Monitor;

	(** This finalizer disposes the meta data of an object. *)
	(** It is guaranteed to be called during the disposal of any object instance. *)
	PROCEDURE ~Finalize-;
	VAR BaseDescriptor {UNTRACED} EXTERN "BaseTypes.Pointer": Descriptor;
	PROCEDURE Unlink  (activity {UNTRACED}: OBJECT) EXTERN "Activities.Process.Unlink";
	BEGIN {UNCOOPERATIVE, UNCHECKED}
		IF action # NIL THEN
			IF action.activity # NIL THEN Unlink (action.activity); action.activity := NIL END;
			Queues.Dispose (action.waitingQueue);
		END;
		IF monitor # NIL THEN
			monitor.owner := NIL;
			monitor.waitingSentinel := NIL;
			Queues.Dispose (monitor.blockedQueue);
			Queues.Dispose (monitor.waitingQueue);
		END;
		descriptor := ADDRESS OF BaseDescriptor;
	END Finalize;

END Object;

(** Represents a stack frame of an activity. *)
TYPE StackFrame* = OBJECT {UNSAFE,PLAIN}

	VAR descriptor*: ADDRESS;
	VAR previous*: ADDRESS;
	VAR caller*: PROCEDURE;

	(** Resets the stack frame by resetting all local variables containing pointers. *)
	(** This procedure is generated by the compiler and resets local variables and parameters. *)
	PROCEDURE Reset-;
	BEGIN {UNCOOPERATIVE, UNCHECKED}
	END Reset;

END StackFrame;

END BaseTypes.