MODULE OFS;
	IMPORT SYSTEM, Kernel, Log, Strings;
CONST 
	ReadOnly* = 0; 
	Removable* = 1; 
	EnumSize* = 0; 
	EnumTime* = 1; 
	EnumRecursive* = 2; 
	EnumStop* = 15; 
	Ok* = 0; 
	Unsupported* =  -1; 
	Error* = 2; 
	InvalidAddress =  -1; 
	PreLength = 16; 
	LocalLength = 32; 
	FileNameLength = (PreLength + LocalLength); 
	BitmapSize = 4096; 
	thisModuleName = \"OFS"\; 
	MinVolSize = 4; 
	SF = 29; 
	DirMark* = 2602476429; 
	HeaderMark = 2611420550; 
	MapMark = 2620364671; 
	DirRootAdr = (1 * SF); 
	MaxFiles = 10; 
	MaxBuffers = 2; 
	InitHint = (200 * SF); 
	SS* = 4096; 
	STS = 128; 
	XS = (SS DIV 4); 
	HS = 568; 
	DirPgSize = 102; 
	N = (DirPgSize DIV 2); 
	FillerSize = 4; 
	MapIndexSize = ((SS - 4) DIV 4); 
	MapSize = (SS DIV 4); 
TYPE 
	Array = ARRAY 2000 OF SIGNED32; 

	EntryHandler* = PROCEDURE (CONST name: ARRAY OF CHAR; time, date, size: SIZE; VAR flags: SET); 

	DiskSector* = RECORD 
	END; 

	Volume* = POINTER TO VolumeDesc; 

	VolumeDesc* = RECORD 
		name*: ARRAY 32 OF CHAR; 
		blockSize*: SIZE; 
		size*: SIZE; 
		flags*: SET; 
		AllocBlock*: PROCEDURE (vol: Volume; hint: SIZE; VAR adr: SIZE; VAR res: INTEGER); 
		FreeBlock*, MarkBlock*: PROCEDURE (vol: Volume; adr: SIZE; VAR res: INTEGER); 
		Marked*: PROCEDURE (vol: Volume; adr: SIZE; VAR res: INTEGER):BOOLEAN; 
		Available*: PROCEDURE (vol: Volume):SIZE; 
		GetBlock*, PutBlock*: PROCEDURE (vol: Volume; adr: SIZE; VAR blk: ARRAY OF SYSTEM.BYTE; ofs: SIZE; VAR res: INTEGER); 
		Finalize*: PROCEDURE (vol: Volume); 
		Sync*: PROCEDURE (vol: Volume); 
		used: SIZE; 
		map: ARRAY BitmapSize OF SET; 
	END; 

	Prefix* = ARRAY PreLength OF CHAR; 

	LocalName* = ARRAY LocalLength OF CHAR; 

	FileName* = ARRAY FileNameLength OF CHAR; 

	FileSystem* = POINTER TO FileSystemDesc; 

	File* = POINTER TO FileDesc; 

	Buffer* = POINTER TO BufferRecord; 

	Rider* = RECORD 
		eof*: BOOLEAN; 
		res*: INTEGER; 
		apos*, bpos*: SIZE; 
		hint*: Buffer; 
		file*: File; 
		fs*: FileSystem; 
	END; 

	FileHd = POINTER TO FileHeader; 

	DataSector = RECORD (DiskSector)
		B: ARRAY SS OF CHAR; 
	END; 

	BufferRecord* = RECORD 
		apos*, lim*: SIZE; 
		mod*: BOOLEAN; 
		next*: Buffer; 
		data*: DataSector; 
	END; 

	IndexSector = RECORD (DiskSector)
		x: ARRAY XS OF SIGNED32; 
	END; 

	SectorTable = ARRAY STS OF SIZE; 

	FileDesc* = RECORD 
		key*: SIZE; 
		fs*: FileSystem; 
		next*: File; 
		aleng, bleng: SIZE; 
		modH, registered: BOOLEAN; 
		sechint: SIZE; 
		name: FileName; 
		time: SIZE; 
		ext: SIZE; 
		firstbuf*: Buffer; 
		sec: SectorTable; 
	END; 

	FileSystemDesc* = RECORD 
		next: FileSystem; 
		link: FileSystem; 
		prefix*: Prefix; 
		desc*: ARRAY 32 OF CHAR; 
		vol*: Volume; 
	END; 

	FileHeader = RECORD (DiskSector)
		mark: SIZE; 
		name: LocalName; 
		aleng, bleng: SIZE; 
		date, time: SIZE; 
		sec: SectorTable; 
		ext: SIZE; 
		data: ARRAY (SS - HS) OF CHAR; 
	END; 

	DirEntry = RECORD 
		name: LocalName; 
		adr: SIZE; 
		p: SIZE; 
	END; 

	DirPage = RECORD (DiskSector)
		mark: SIZE; 
		m: SIZE; 
		p0: SIZE; 
		fill: ARRAY FillerSize OF CHAR; 
		e: ARRAY DirPgSize OF DirEntry; 
	END; 

	MapIndex = RECORD (DiskSector)
		mark: SIZE; 
		index: ARRAY MapIndexSize OF SIZE; 
	END; 

	MapSector = RECORD (DiskSector)
		map: ARRAY MapSize OF SET; 
	END; 
VAR 
	hp: FileHeader; 
	fullname: FileName; 
	fsroot: FileSystem; 
	fsmount: FileSystem; 
	froot: File; 
	filePool: File; 

	PROCEDURE ^ First*(): FileSystem; 
	PROCEDURE ^ JoinName*(CONST prefix, name: ARRAY OF CHAR; VAR fullname: ARRAY OF CHAR); 
	PROCEDURE ^ FSGetSector(vol: Volume; src: SIZE; VAR dest: DiskSector); 
	PROCEDURE ^ FSPutSector(vol: Volume; dest: SIZE; VAR src: DiskSector); 
	PROCEDURE ^ FSAllocSector(vol: Volume; hint: SIZE; VAR sec: SIZE); 
	PROCEDURE ^ FSMarkSector(vol: Volume; sec: SIZE); 
	PROCEDURE ^ FSFreeSector(vol: Volume; sec: SIZE); 
	PROCEDURE ^ FSMarked(vol: Volume; sec: SIZE): BOOLEAN; 
	PROCEDURE ^ FSSize(vol: Volume): SIZE; 
	PROCEDURE ^ Search(vol: Volume; CONST name: FileName; VAR A: SIZE); 
	PROCEDURE ^ CopyDirEntry(CONST src: DirEntry; VAR dest: DirEntry); 
	PROCEDURE ^ insert(vol: Volume; CONST name: FileName; dpg0: SIZE; VAR h: BOOLEAN; VAR v: DirEntry; fad: SIZE; VAR replacedFad: SIZE); 
	PROCEDURE ^ Insert(vol: Volume; CONST name: FileName; fad: SIZE; VAR replacedFad: SIZE); 
	PROCEDURE ^ underflow(vol: Volume; VAR c: DirPage; dpg0: SIZE; s: SIZE; VAR h: BOOLEAN); 
	PROCEDURE ^ del(vol: Volume; dpg1: SIZE; VAR h: BOOLEAN; VAR a: DirPage; VAR R: SIZE); 
	PROCEDURE ^ delete(vol: Volume; CONST name: FileName; dpg0: SIZE; VAR h: BOOLEAN; VAR fad: SIZE); 
	PROCEDURE ^ DirDelete(vol: Volume; CONST name: FileName; VAR fad: SIZE); 
	PROCEDURE ^ MatchPrefix(CONST mask, name: ARRAY OF CHAR; VAR pos, diff: SIZE); 
	PROCEDURE ^ Match(pos: SIZE; CONST pat, name: ARRAY OF CHAR): BOOLEAN; 
	PROCEDURE ^ enumerate(fs: FileSystem; CONST mask: ARRAY OF CHAR; dpg: SIZE; VAR flags: SET; proc: EntryHandler); 
	PROCEDURE ^ sift(L, R: SIZE; VAR A: Array); 
	PROCEDURE ^ MarkSectors(vol: Volume; VAR k: SIZE; VAR A: Array; VAR bad: BOOLEAN; VAR files: SIZE); 
	PROCEDURE ^ TraverseDir(vol: Volume; dpg: SIZE; VAR A: Array; VAR k: SIZE; VAR bad: BOOLEAN; VAR files: SIZE); 
	PROCEDURE ^ DirStartup(vol: Volume; VAR init: BOOLEAN); 
	PROCEDURE ^ DirInit(vol: Volume; VAR init: BOOLEAN); 
	PROCEDURE ^ DirCleanup(vol: Volume); 
	PROCEDURE ^ Check(CONST s: ARRAY OF CHAR; VAR name: FileName; VAR res: INTEGER); 
	PROCEDURE ^ FSNew(fs: FileSystem; CONST name: ARRAY OF CHAR): File; 
	PROCEDURE ^ CopySectorTable(CONST src: ARRAY OF SIZE; VAR dest: ARRAY OF SIZE); 
	PROCEDURE ^ UpdateHeader(f: File; VAR h: FileHeader); 
	PROCEDURE ^ ReadBuf(f: File; buf: Buffer; pos: SIZE); 
	PROCEDURE ^ NewSuper(f: File); 
	PROCEDURE ^ WriteBuf(f: File; buf: Buffer); 
	PROCEDURE ^ SearchBuf(f: File; pos: SIZE): Buffer; 
	PROCEDURE ^ GetBuf(f: File; pos: SIZE): Buffer; 
	PROCEDURE ^ FileKey(fs: FileSystem; CONST name: ARRAY OF CHAR): SIZE; 
	PROCEDURE ^ FSOld(fs: FileSystem; CONST name: ARRAY OF CHAR): File; 
	PROCEDURE ^ Unbuffer(f: File); 
	PROCEDURE ^ FindOpenFile*(fs: FileSystem; key: SIZE): File; 
	PROCEDURE ^ LogGC(CONST procname, prefix, name: ARRAY OF CHAR); 
	PROCEDURE ^ Free(vol: Volume; adr: SIZE); 
	PROCEDURE ^ PurgeOnDisk(fs: FileSystem; hdadr: SIZE); 
	PROCEDURE ^ FSRegister(f: File; VAR res: SIZE); 
	PROCEDURE ^ PutIntoFilePool(f: File); 
	PROCEDURE ^ LogFS(fs: FileSystem); 
	PROCEDURE ^ FileCleanup(f: File); 
	PROCEDURE ^ Length*(f: File): SIZE; 
	PROCEDURE ^ GetTime*(f: File; VAR t: SIZE); 
	PROCEDURE ^ SetTime*(f: File; t: SIZE); 
	PROCEDURE ^ Set*(VAR r: Rider; f: File; pos: SIZE); 
	PROCEDURE ^ Pos*(VAR r: Rider): SIZE; 
	PROCEDURE ^ Read*(VAR r: Rider; VAR x: CHAR); 
	PROCEDURE ^ ReadBytes*(VAR r: Rider; VAR x: ARRAY OF SYSTEM.BYTE; n: SIZE); 
	PROCEDURE ^ ReadInt*(VAR r: Rider; VAR x: SIZE); 
	PROCEDURE ^ ReadSet*(VAR r: Rider; VAR x: SET); 
	PROCEDURE ^ ReadReal*(VAR r: Rider; VAR x: REAL); 
	PROCEDURE ^ NewSub(f: File); 
	PROCEDURE ^ Write*(VAR r: Rider; x: CHAR); 
	PROCEDURE ^ WriteBytes*(VAR r: Rider; CONST x: ARRAY OF SYSTEM.BYTE; n: SIZE); 
	PROCEDURE ^ WriteInt*(VAR r: Rider; VAR x: SIZE); 
	PROCEDURE ^ WriteSet*(VAR r: Rider; VAR x: SET); 
	PROCEDURE ^ WriteReal*(VAR r: Rider; VAR x: REAL); 
	PROCEDURE ^ Purge(fs: FileSystem; f: File); 
	PROCEDURE ^ Registered(fs: FileSystem; f: File): BOOLEAN; 
	PROCEDURE ^ FSDelete(fs: FileSystem; CONST name: ARRAY OF CHAR; VAR key: SIZE; VAR res: INTEGER); 
	PROCEDURE ^ FSRename(fs: FileSystem; CONST old, new: ARRAY OF CHAR; VAR res: SIZE); 
	PROCEDURE ^ GetName*(f: File; VAR name: ARRAY OF CHAR); 
	PROCEDURE ^ Finalize(fs: FileSystem); 
	PROCEDURE ^ This*(CONST prefix: ARRAY OF CHAR): FileSystem; 
	PROCEDURE ^ Add(fs: FileSystem; CONST prefix: ARRAY OF CHAR); 
	PROCEDURE ^ Format(vol: Volume); 
	PROCEDURE ^ NewFS*(CONST prefix: Prefix; format: BOOLEAN; vol: Volume); 
	PROCEDURE ^ DefaultAllocBlock*(vol: Volume; hint: SIZE; VAR adr: SIZE; VAR res: INTEGER); 
	PROCEDURE ^ DefaultFreeBlock*(vol: Volume; adr: SIZE; VAR res: INTEGER); 
	PROCEDURE ^ DefaultMarkBlock*(vol: Volume; adr: SIZE; VAR res: INTEGER); 
	PROCEDURE ^ DefaultMarked*(vol: Volume; adr: SIZE; VAR res: INTEGER): BOOLEAN; 
	PROCEDURE ^ DefaultAvailable*(vol: Volume): SIZE; 
	PROCEDURE ^ DefaultSync*(vol: Volume); 
	PROCEDURE ^ InitVol*(vol: Volume); 
	PROCEDURE ^ DefaultFinalizeVol*(vol: Volume); 
	PROCEDURE ^ SplitName(CONST fullname: ARRAY OF CHAR; VAR prefix, name: ARRAY OF CHAR); 
	PROCEDURE ^ DeleteFS(fs: FileSystem); 
	PROCEDURE ^ Promote*(fs: FileSystem); 
	PROCEDURE ^ Close*(f: File); 
	PROCEDURE ^ Remove*(fs: FileSystem); 
	PROCEDURE ^ Next*(fs: FileSystem): FileSystem; 
	PROCEDURE ^ Open(fs: FileSystem; CONST fname: ARRAY OF CHAR): File; 
	PROCEDURE ^ Old*(CONST name: ARRAY OF CHAR): File; 
	PROCEDURE ^ New*(CONST name: ARRAY OF CHAR): File; 
	PROCEDURE ^ Delete*(VAR name: ARRAY OF CHAR; VAR res: INTEGER); 
	PROCEDURE ^ Rename*(CONST old, new: ARRAY OF CHAR; VAR res: SIZE); 
	PROCEDURE ^ Register*(f: File); 
	PROCEDURE ^ Available*(CONST name: ARRAY OF CHAR): SIZE; 
	PROCEDURE ^ Enumerate*(CONST mask: ARRAY OF CHAR; VAR flags: SET; proc: EntryHandler); 
	PROCEDURE ^ HasOpenFiles*(fs: FileSystem): BOOLEAN; 
	PROCEDURE ^ FSCleanup; 
	PROCEDURE ^ InitFilePool; 
BEGIN
END OFS.
